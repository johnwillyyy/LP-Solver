{"ast":null,"code":"var Q = Object.defineProperty;\nvar s = (e, t) => Q(e, \"name\", {\n    value: t,\n    configurable: !0\n  }),\n  I = (e => typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(e, {\n    get: (t, o) => (typeof require < \"u\" ? require : t)[o]\n  }) : e)(function (e) {\n    if (typeof require < \"u\") return require.apply(this, arguments);\n    throw new Error('Dynamic require of \"' + e + '\" is not supported');\n  });\nfunction Z(e) {\n  return !isNaN(parseFloat(e)) && isFinite(e);\n}\ns(Z, \"_isNumber\");\nfunction E(e) {\n  return e.charAt(0).toUpperCase() + e.substring(1);\n}\ns(E, \"_capitalize\");\nfunction k(e) {\n  return function () {\n    return this[e];\n  };\n}\ns(k, \"_getter\");\nvar w = [\"isConstructor\", \"isEval\", \"isNative\", \"isToplevel\"],\n  N = [\"columnNumber\", \"lineNumber\"],\n  _ = [\"fileName\", \"functionName\", \"source\"],\n  ee = [\"args\"],\n  te = [\"evalOrigin\"],\n  O = w.concat(N, _, ee, te);\nfunction p(e) {\n  if (e) for (var t = 0; t < O.length; t++) e[O[t]] !== void 0 && this[\"set\" + E(O[t])](e[O[t]]);\n}\ns(p, \"StackFrame\");\np.prototype = {\n  getArgs: function () {\n    return this.args;\n  },\n  setArgs: function (e) {\n    if (Object.prototype.toString.call(e) !== \"[object Array]\") throw new TypeError(\"Args must be an Array\");\n    this.args = e;\n  },\n  getEvalOrigin: function () {\n    return this.evalOrigin;\n  },\n  setEvalOrigin: function (e) {\n    if (e instanceof p) this.evalOrigin = e;else if (e instanceof Object) this.evalOrigin = new p(e);else throw new TypeError(\"Eval Origin must be an Object or StackFrame\");\n  },\n  toString: function () {\n    var e = this.getFileName() || \"\",\n      t = this.getLineNumber() || \"\",\n      o = this.getColumnNumber() || \"\",\n      r = this.getFunctionName() || \"\";\n    return this.getIsEval() ? e ? \"[eval] (\" + e + \":\" + t + \":\" + o + \")\" : \"[eval]:\" + t + \":\" + o : r ? r + \" (\" + e + \":\" + t + \":\" + o + \")\" : e + \":\" + t + \":\" + o;\n  }\n};\np.fromString = s(function (t) {\n  var o = t.indexOf(\"(\"),\n    r = t.lastIndexOf(\")\"),\n    a = t.substring(0, o),\n    n = t.substring(o + 1, r).split(\",\"),\n    i = t.substring(r + 1);\n  if (i.indexOf(\"@\") === 0) var c = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(i, \"\"),\n    l = c[1],\n    d = c[2],\n    u = c[3];\n  return new p({\n    functionName: a,\n    args: n || void 0,\n    fileName: l,\n    lineNumber: d || void 0,\n    columnNumber: u || void 0\n  });\n}, \"StackFrame$$fromString\");\nfor (b = 0; b < w.length; b++) p.prototype[\"get\" + E(w[b])] = k(w[b]), p.prototype[\"set\" + E(w[b])] = function (e) {\n  return function (t) {\n    this[e] = !!t;\n  };\n}(w[b]);\nvar b;\nfor (v = 0; v < N.length; v++) p.prototype[\"get\" + E(N[v])] = k(N[v]), p.prototype[\"set\" + E(N[v])] = function (e) {\n  return function (t) {\n    if (!Z(t)) throw new TypeError(e + \" must be a Number\");\n    this[e] = Number(t);\n  };\n}(N[v]);\nvar v;\nfor (h = 0; h < _.length; h++) p.prototype[\"get\" + E(_[h])] = k(_[h]), p.prototype[\"set\" + E(_[h])] = function (e) {\n  return function (t) {\n    this[e] = String(t);\n  };\n}(_[h]);\nvar h,\n  x = p;\nfunction ne() {\n  var e = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m,\n    t = /^(eval@)?(\\[native code])?$/;\n  return {\n    parse: s(function (r) {\n      if (r.stack && r.stack.match(e)) return this.parseV8OrIE(r);\n      if (r.stack) return this.parseFFOrSafari(r);\n      throw new Error(\"Cannot parse given Error object\");\n    }, \"ErrorStackParser$$parse\"),\n    extractLocation: s(function (r) {\n      if (r.indexOf(\":\") === -1) return [r];\n      var a = /(.+?)(?::(\\d+))?(?::(\\d+))?$/,\n        n = a.exec(r.replace(/[()]/g, \"\"));\n      return [n[1], n[2] || void 0, n[3] || void 0];\n    }, \"ErrorStackParser$$extractLocation\"),\n    parseV8OrIE: s(function (r) {\n      var a = r.stack.split(`\n`).filter(function (n) {\n        return !!n.match(e);\n      }, this);\n      return a.map(function (n) {\n        n.indexOf(\"(eval \") > -1 && (n = n.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\"));\n        var i = n.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\"),\n          c = i.match(/ (\\(.+\\)$)/);\n        i = c ? i.replace(c[0], \"\") : i;\n        var l = this.extractLocation(c ? c[1] : i),\n          d = c && i || void 0,\n          u = [\"eval\", \"<anonymous>\"].indexOf(l[0]) > -1 ? void 0 : l[0];\n        return new x({\n          functionName: d,\n          fileName: u,\n          lineNumber: l[1],\n          columnNumber: l[2],\n          source: n\n        });\n      }, this);\n    }, \"ErrorStackParser$$parseV8OrIE\"),\n    parseFFOrSafari: s(function (r) {\n      var a = r.stack.split(`\n`).filter(function (n) {\n        return !n.match(t);\n      }, this);\n      return a.map(function (n) {\n        if (n.indexOf(\" > eval\") > -1 && (n = n.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\")), n.indexOf(\"@\") === -1 && n.indexOf(\":\") === -1) return new x({\n          functionName: n\n        });\n        var i = /((.*\".+\"[^@]*)?[^@]*)(?:@)/,\n          c = n.match(i),\n          l = c && c[1] ? c[1] : void 0,\n          d = this.extractLocation(n.replace(i, \"\"));\n        return new x({\n          functionName: l,\n          fileName: d[0],\n          lineNumber: d[1],\n          columnNumber: d[2],\n          source: n\n        });\n      }, this);\n    }, \"ErrorStackParser$$parseFFOrSafari\")\n  };\n}\ns(ne, \"ErrorStackParser\");\nvar re = new ne();\nvar C = re;\nvar g = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && !process.browser,\n  A = g && typeof module < \"u\" && typeof module.exports < \"u\" && typeof I < \"u\" && typeof __dirname < \"u\",\n  W = g && !A,\n  Ne = typeof globalThis.Bun < \"u\",\n  ie = typeof Deno < \"u\",\n  B = !g && !ie,\n  $ = B && typeof window == \"object\" && typeof document == \"object\" && typeof document.createElement == \"function\" && \"sessionStorage\" in window && typeof importScripts != \"function\",\n  j = B && typeof importScripts == \"function\" && typeof self == \"object\",\n  _e = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent.indexOf(\"Chrome\") == -1 && navigator.userAgent.indexOf(\"Safari\") > -1;\nvar z, D, V, H, L;\nasync function T() {\n  if (!g || (z = (await import(\"node:url\")).default, H = await import(\"node:fs\"), L = await import(\"node:fs/promises\"), V = (await import(\"node:vm\")).default, D = await import(\"node:path\"), U = D.sep, typeof I < \"u\")) return;\n  let e = H,\n    t = await import(\"node:crypto\"),\n    o = await import(\"ws\"),\n    r = await import(\"node:child_process\"),\n    a = {\n      fs: e,\n      crypto: t,\n      ws: o,\n      child_process: r\n    };\n  globalThis.require = function (n) {\n    return a[n];\n  };\n}\ns(T, \"initNodeModules\");\nfunction oe(e, t) {\n  return D.resolve(t || \".\", e);\n}\ns(oe, \"node_resolvePath\");\nfunction ae(e, t) {\n  return t === void 0 && (t = location), new URL(e, t).toString();\n}\ns(ae, \"browser_resolvePath\");\nvar P;\ng ? P = oe : P = ae;\nvar U;\ng || (U = \"/\");\nfunction se(e, t) {\n  return e.startsWith(\"file://\") && (e = e.slice(7)), e.includes(\"://\") ? {\n    response: fetch(e)\n  } : {\n    binary: L.readFile(e).then(o => new Uint8Array(o.buffer, o.byteOffset, o.byteLength))\n  };\n}\ns(se, \"node_getBinaryResponse\");\nfunction ce(e, t) {\n  let o = new URL(e, location);\n  return {\n    response: fetch(o, t ? {\n      integrity: t\n    } : {})\n  };\n}\ns(ce, \"browser_getBinaryResponse\");\nvar F;\ng ? F = se : F = ce;\nasync function q(e, t) {\n  let {\n    response: o,\n    binary: r\n  } = F(e, t);\n  if (r) return r;\n  let a = await o;\n  if (!a.ok) throw new Error(`Failed to load '${e}': request failed.`);\n  return new Uint8Array(await a.arrayBuffer());\n}\ns(q, \"loadBinaryFile\");\nvar R;\nif ($) R = s(async e => await import(e), \"loadScript\");else if (j) R = s(async e => {\n  try {\n    globalThis.importScripts(e);\n  } catch (t) {\n    if (t instanceof TypeError) await import(e);else throw t;\n  }\n}, \"loadScript\");else if (g) R = le;else throw new Error(\"Cannot determine runtime environment\");\nasync function le(e) {\n  e.startsWith(\"file://\") && (e = e.slice(7)), e.includes(\"://\") ? V.runInThisContext(await (await fetch(e)).text()) : await import(z.pathToFileURL(e).href);\n}\ns(le, \"nodeLoadScript\");\nasync function J(e) {\n  if (g) {\n    await T();\n    let t = await L.readFile(e, {\n      encoding: \"utf8\"\n    });\n    return JSON.parse(t);\n  } else return await (await fetch(e)).json();\n}\ns(J, \"loadLockFile\");\nasync function K() {\n  if (A) return __dirname;\n  let e;\n  try {\n    throw new Error();\n  } catch (r) {\n    e = r;\n  }\n  let t = C.parse(e)[0].fileName;\n  if (g && !t.startsWith(\"file://\") && (t = `file://${t}`), W) {\n    let r = await import(\"node:path\");\n    return (await import(\"node:url\")).fileURLToPath(r.dirname(t));\n  }\n  let o = t.lastIndexOf(U);\n  if (o === -1) throw new Error(\"Could not extract indexURL path from pyodide module location\");\n  return t.slice(0, o);\n}\ns(K, \"calculateDirname\");\nfunction Y(e) {\n  let t = e.FS,\n    o = e.FS.filesystems.MEMFS,\n    r = e.PATH,\n    a = {\n      DIR_MODE: 16895,\n      FILE_MODE: 33279,\n      mount: function (n) {\n        if (!n.opts.fileSystemHandle) throw new Error(\"opts.fileSystemHandle is required\");\n        return o.mount.apply(null, arguments);\n      },\n      syncfs: async (n, i, c) => {\n        try {\n          let l = a.getLocalSet(n),\n            d = await a.getRemoteSet(n),\n            u = i ? d : l,\n            m = i ? l : d;\n          await a.reconcile(n, u, m), c(null);\n        } catch (l) {\n          c(l);\n        }\n      },\n      getLocalSet: n => {\n        let i = Object.create(null);\n        function c(u) {\n          return u !== \".\" && u !== \"..\";\n        }\n        s(c, \"isRealDir\");\n        function l(u) {\n          return m => r.join2(u, m);\n        }\n        s(l, \"toAbsolute\");\n        let d = t.readdir(n.mountpoint).filter(c).map(l(n.mountpoint));\n        for (; d.length;) {\n          let u = d.pop(),\n            m = t.stat(u);\n          t.isDir(m.mode) && d.push.apply(d, t.readdir(u).filter(c).map(l(u))), i[u] = {\n            timestamp: m.mtime,\n            mode: m.mode\n          };\n        }\n        return {\n          type: \"local\",\n          entries: i\n        };\n      },\n      getRemoteSet: async n => {\n        let i = Object.create(null),\n          c = await de(n.opts.fileSystemHandle);\n        for (let [l, d] of c) l !== \".\" && (i[r.join2(n.mountpoint, l)] = {\n          timestamp: d.kind === \"file\" ? (await d.getFile()).lastModifiedDate : new Date(),\n          mode: d.kind === \"file\" ? a.FILE_MODE : a.DIR_MODE\n        });\n        return {\n          type: \"remote\",\n          entries: i,\n          handles: c\n        };\n      },\n      loadLocalEntry: n => {\n        let c = t.lookupPath(n).node,\n          l = t.stat(n);\n        if (t.isDir(l.mode)) return {\n          timestamp: l.mtime,\n          mode: l.mode\n        };\n        if (t.isFile(l.mode)) return c.contents = o.getFileDataAsTypedArray(c), {\n          timestamp: l.mtime,\n          mode: l.mode,\n          contents: c.contents\n        };\n        throw new Error(\"node type not supported\");\n      },\n      storeLocalEntry: (n, i) => {\n        if (t.isDir(i.mode)) t.mkdirTree(n, i.mode);else if (t.isFile(i.mode)) t.writeFile(n, i.contents, {\n          canOwn: !0\n        });else throw new Error(\"node type not supported\");\n        t.chmod(n, i.mode), t.utime(n, i.timestamp, i.timestamp);\n      },\n      removeLocalEntry: n => {\n        var i = t.stat(n);\n        t.isDir(i.mode) ? t.rmdir(n) : t.isFile(i.mode) && t.unlink(n);\n      },\n      loadRemoteEntry: async n => {\n        if (n.kind === \"file\") {\n          let i = await n.getFile();\n          return {\n            contents: new Uint8Array(await i.arrayBuffer()),\n            mode: a.FILE_MODE,\n            timestamp: i.lastModifiedDate\n          };\n        } else {\n          if (n.kind === \"directory\") return {\n            mode: a.DIR_MODE,\n            timestamp: new Date()\n          };\n          throw new Error(\"unknown kind: \" + n.kind);\n        }\n      },\n      storeRemoteEntry: async (n, i, c) => {\n        let l = n.get(r.dirname(i)),\n          d = t.isFile(c.mode) ? await l.getFileHandle(r.basename(i), {\n            create: !0\n          }) : await l.getDirectoryHandle(r.basename(i), {\n            create: !0\n          });\n        if (d.kind === \"file\") {\n          let u = await d.createWritable();\n          await u.write(c.contents), await u.close();\n        }\n        n.set(i, d);\n      },\n      removeRemoteEntry: async (n, i) => {\n        await n.get(r.dirname(i)).removeEntry(r.basename(i)), n.delete(i);\n      },\n      reconcile: async (n, i, c) => {\n        let l = 0,\n          d = [];\n        Object.keys(i.entries).forEach(function (f) {\n          let y = i.entries[f],\n            S = c.entries[f];\n          (!S || t.isFile(y.mode) && y.timestamp.getTime() > S.timestamp.getTime()) && (d.push(f), l++);\n        }), d.sort();\n        let u = [];\n        if (Object.keys(c.entries).forEach(function (f) {\n          i.entries[f] || (u.push(f), l++);\n        }), u.sort().reverse(), !l) return;\n        let m = i.type === \"remote\" ? i.handles : c.handles;\n        for (let f of d) {\n          let y = r.normalize(f.replace(n.mountpoint, \"/\")).substring(1);\n          if (c.type === \"local\") {\n            let S = m.get(y),\n              X = await a.loadRemoteEntry(S);\n            a.storeLocalEntry(f, X);\n          } else {\n            let S = a.loadLocalEntry(f);\n            await a.storeRemoteEntry(m, y, S);\n          }\n        }\n        for (let f of u) if (c.type === \"local\") a.removeLocalEntry(f);else {\n          let y = r.normalize(f.replace(n.mountpoint, \"/\")).substring(1);\n          await a.removeRemoteEntry(m, y);\n        }\n      }\n    };\n  e.FS.filesystems.NATIVEFS_ASYNC = a;\n}\ns(Y, \"initializeNativeFS\");\nvar de = s(async e => {\n  let t = [];\n  async function o(a) {\n    for await (let n of a.values()) t.push(n), n.kind === \"directory\" && (await o(n));\n  }\n  s(o, \"collect\"), await o(e);\n  let r = new Map();\n  r.set(\".\", e);\n  for (let a of t) {\n    let n = (await e.resolve(a)).join(\"/\");\n    r.set(n, a);\n  }\n  return r;\n}, \"getFsHandles\");\nfunction G(e) {\n  let t = {\n    noImageDecoding: !0,\n    noAudioDecoding: !0,\n    noWasmDecoding: !1,\n    preRun: ge(e),\n    quit(o, r) {\n      throw t.exited = {\n        status: o,\n        toThrow: r\n      }, r;\n    },\n    print: e.stdout,\n    printErr: e.stderr,\n    arguments: e.args,\n    API: {\n      config: e\n    },\n    locateFile: o => e.indexURL + o,\n    instantiateWasm: ye(e.indexURL)\n  };\n  return t;\n}\ns(G, \"createSettings\");\nfunction ue(e) {\n  return function (t) {\n    let o = \"/\";\n    try {\n      t.FS.mkdirTree(e);\n    } catch (r) {\n      console.error(`Error occurred while making a home directory '${e}':`), console.error(r), console.error(`Using '${o}' for a home directory instead`), e = o;\n    }\n    t.FS.chdir(e);\n  };\n}\ns(ue, \"createHomeDirectory\");\nfunction fe(e) {\n  return function (t) {\n    Object.assign(t.ENV, e);\n  };\n}\ns(fe, \"setEnvironment\");\nfunction me(e) {\n  return t => {\n    for (let o of e) t.FS.mkdirTree(o), t.FS.mount(t.FS.filesystems.NODEFS, {\n      root: o\n    }, o);\n  };\n}\ns(me, \"mountLocalDirectories\");\nfunction pe(e) {\n  let t = q(e);\n  return o => {\n    let r = o._py_version_major(),\n      a = o._py_version_minor();\n    o.FS.mkdirTree(\"/lib\"), o.FS.mkdirTree(`/lib/python${r}.${a}/site-packages`), o.addRunDependency(\"install-stdlib\"), t.then(n => {\n      o.FS.writeFile(`/lib/python${r}${a}.zip`, n);\n    }).catch(n => {\n      console.error(\"Error occurred while installing the standard library:\"), console.error(n);\n    }).finally(() => {\n      o.removeRunDependency(\"install-stdlib\");\n    });\n  };\n}\ns(pe, \"installStdlib\");\nfunction ge(e) {\n  let t;\n  return e.stdLibURL != null ? t = e.stdLibURL : t = e.indexURL + \"python_stdlib.zip\", [pe(t), ue(e.env.HOME), fe(e.env), me(e._node_mounts), Y];\n}\ns(ge, \"getFileSystemInitializationFuncs\");\nfunction ye(e) {\n  if (typeof WasmOffsetConverter < \"u\") return;\n  let {\n    binary: t,\n    response: o\n  } = F(e + \"pyodide.asm.wasm\");\n  return function (r, a) {\n    return async function () {\n      try {\n        let n;\n        o ? n = await WebAssembly.instantiateStreaming(o, r) : n = await WebAssembly.instantiate(await t, r);\n        let {\n          instance: i,\n          module: c\n        } = n;\n        a(i, c);\n      } catch (n) {\n        console.warn(\"wasm instantiation failed!\"), console.warn(n);\n      }\n    }(), {};\n  };\n}\ns(ye, \"getInstantiateWasmFunc\");\nvar M = \"0.27.3\";\nasync function $e(e = {}) {\n  var u, m;\n  await T();\n  let t = e.indexURL || (await K());\n  t = P(t), t.endsWith(\"/\") || (t += \"/\"), e.indexURL = t;\n  let o = {\n      fullStdLib: !1,\n      jsglobals: globalThis,\n      stdin: globalThis.prompt ? globalThis.prompt : void 0,\n      lockFileURL: t + \"pyodide-lock.json\",\n      args: [],\n      _node_mounts: [],\n      env: {},\n      packageCacheDir: t,\n      packages: [],\n      enableRunUntilComplete: !1,\n      checkAPIVersion: !0,\n      BUILD_ID: \"285ab4f913dd7f9216f3d9f225a9425b58b1c1cf058302946162bb3873fa1e70\"\n    },\n    r = Object.assign(o, e);\n  (u = r.env).HOME ?? (u.HOME = \"/home/pyodide\"), (m = r.env).PYTHONINSPECT ?? (m.PYTHONINSPECT = \"1\");\n  let a = G(r),\n    n = a.API;\n  if (n.lockFilePromise = J(r.lockFileURL), typeof _createPyodideModule != \"function\") {\n    let f = `${r.indexURL}pyodide.asm.js`;\n    await R(f);\n  }\n  let i;\n  if (e._loadSnapshot) {\n    let f = await e._loadSnapshot;\n    ArrayBuffer.isView(f) ? i = f : i = new Uint8Array(f), a.noInitialRun = !0, a.INITIAL_MEMORY = i.length;\n  }\n  let c = await _createPyodideModule(a);\n  if (a.exited) throw a.exited.toThrow;\n  if (e.pyproxyToStringRepr && n.setPyProxyToStringMethod(!0), n.version !== M && r.checkAPIVersion) throw new Error(`Pyodide version does not match: '${M}' <==> '${n.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);\n  c.locateFile = f => {\n    throw new Error(\"Didn't expect to load any more file_packager files!\");\n  };\n  let l;\n  i && (l = n.restoreSnapshot(i));\n  let d = n.finalizeBootstrap(l, e._snapshotDeserializer);\n  return n.sys.path.insert(0, n.config.env.HOME), d.version.includes(\"dev\") || n.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`), n._pyodide.set_excepthook(), await n.packageIndexReady, n.initializeStreams(r.stdin, r.stdout, r.stderr), d;\n}\ns($e, \"loadPyodide\");\nexport { $e as loadPyodide, M as version };","map":{"version":3,"names":["Z","e","isNaN","parseFloat","isFinite","s","E","charAt","toUpperCase","substring","k","w","N","_","ee","te","O","concat","p","t","length","prototype","getArgs","args","setArgs","Object","toString","call","TypeError","getEvalOrigin","evalOrigin","setEvalOrigin","getFileName","getLineNumber","o","getColumnNumber","r","getFunctionName","getIsEval","fromString","indexOf","lastIndexOf","a","n","split","i","c","exec","l","d","u","functionName","fileName","lineNumber","columnNumber","b","v","Number","h","String","x","ne","parse","stack","match","parseV8OrIE","parseFFOrSafari","Error","extractLocation","replace","filter","map","source","re","C","g","process","versions","node","browser","A","module","exports","I","__dirname","W","Ne","globalThis","Bun","ie","Deno","B","$","window","document","createElement","importScripts","j","self","_e","navigator","userAgent","z","D","V","H","L","T","default","U","sep","fs","crypto","ws","child_process","require","oe","resolve","ae","location","URL","P","se","startsWith","slice","includes","response","fetch","binary","readFile","then","Uint8Array","buffer","byteOffset","byteLength","ce","integrity","F","q","ok","arrayBuffer","R","le","runInThisContext","text","pathToFileURL","href","J","encoding","JSON","json","K","fileURLToPath","dirname","Y","FS","filesystems","MEMFS","PATH","DIR_MODE","FILE_MODE","mount","opts","fileSystemHandle","apply","arguments","syncfs","getLocalSet","getRemoteSet","m","reconcile","create","join2","readdir","mountpoint","pop","stat","isDir","mode","push","timestamp","mtime","type","entries","de","kind","getFile","lastModifiedDate","Date","handles","loadLocalEntry","lookupPath","isFile","contents","getFileDataAsTypedArray","storeLocalEntry","mkdirTree","writeFile","canOwn","chmod","utime","removeLocalEntry","rmdir","unlink","loadRemoteEntry","storeRemoteEntry","get","getFileHandle","basename","getDirectoryHandle","createWritable","write","close","set","removeRemoteEntry","removeEntry","delete","keys","forEach","f","y","S","getTime","sort","reverse","normalize","X","NATIVEFS_ASYNC","values","Map","join","G","noImageDecoding","noAudioDecoding","noWasmDecoding","preRun","ge","quit","exited","status","toThrow","print","stdout","printErr","stderr","API","config","locateFile","indexURL","instantiateWasm","ye","ue","console","error","chdir","fe","assign","ENV","me","NODEFS","root","pe","_py_version_major","_py_version_minor","addRunDependency","catch","finally","removeRunDependency","stdLibURL","env","HOME","_node_mounts","WasmOffsetConverter","WebAssembly","instantiateStreaming","instantiate","instance","warn","M","$e","endsWith","fullStdLib","jsglobals","stdin","prompt","lockFileURL","packageCacheDir","packages","enableRunUntilComplete","checkAPIVersion","BUILD_ID","PYTHONINSPECT","lockFilePromise","_createPyodideModule","_loadSnapshot","ArrayBuffer","isView","noInitialRun","INITIAL_MEMORY","pyproxyToStringRepr","setPyProxyToStringMethod","version","restoreSnapshot","finalizeBootstrap","_snapshotDeserializer","sys","path","insert","setCdnUrl","_pyodide","set_excepthook","packageIndexReady","initializeStreams","loadPyodide"],"sources":["/home/john/OR-Labs/LP Solver/node_modules/src/js/vendor/stackframe/stackframe.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/vendor/stackframe/error-stack-parser.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/environments.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/compat.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/nativefs.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/emscripten-settings.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/version.ts","/home/john/OR-Labs/LP Solver/node_modules/src/js/pyodide.ts"],"sourcesContent":["// @ts-nocheck\n// Port of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js.\n// Rewritten to ES6 and removed UMD and CommonJS support.\n\nfunction _isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n}\n\nfunction _getter(p) {\n  return function () {\n    return this[p];\n  };\n}\n\nvar booleanProps = [\"isConstructor\", \"isEval\", \"isNative\", \"isToplevel\"];\nvar numericProps = [\"columnNumber\", \"lineNumber\"];\nvar stringProps = [\"fileName\", \"functionName\", \"source\"];\nvar arrayProps = [\"args\"];\nvar objectProps = [\"evalOrigin\"];\n\nvar props = booleanProps.concat(\n  numericProps,\n  stringProps,\n  arrayProps,\n  objectProps,\n);\n\ndeclare namespace StackFrame {\n  export interface StackFrameOptions {\n    isConstructor?: boolean;\n    isEval?: boolean;\n    isNative?: boolean;\n    isToplevel?: boolean;\n    columnNumber?: number;\n    lineNumber?: number;\n    fileName?: string;\n    functionName?: string;\n    source?: string;\n    args?: any[];\n    evalOrigin?: StackFrame;\n  }\n}\n\ndeclare class StackFrame {\n  constructor(obj: StackFrame.StackFrameOptions);\n\n  args?: any[];\n  getArgs(): any[] | undefined;\n  setArgs(args: any[]): void;\n\n  evalOrigin?: StackFrame;\n  getEvalOrigin(): StackFrame | undefined;\n  setEvalOrigin(stackframe: StackFrame): void;\n\n  isConstructor?: boolean;\n  getIsConstructor(): boolean | undefined;\n  setIsConstructor(isConstructor: boolean): void;\n\n  isEval?: boolean;\n  getIsEval(): boolean | undefined;\n  setIsEval(isEval: boolean): void;\n\n  isNative?: boolean;\n  getIsNative(): boolean | undefined;\n  setIsNative(isNative: boolean): void;\n\n  isToplevel?: boolean;\n  getIsToplevel(): boolean | undefined;\n  setIsToplevel(isToplevel: boolean): void;\n\n  columnNumber?: number;\n  getColumnNumber(): number | undefined;\n  setColumnNumber(columnNumber: number): void;\n\n  lineNumber?: number;\n  getLineNumber(): number | undefined;\n  setLineNumber(lineNumber: number): void;\n\n  fileName?: string;\n  getFileName(): string | undefined;\n  setFileName(fileName: string): void;\n\n  functionName?: string;\n  getFunctionName(): string | undefined;\n  setFunctionName(functionName: string): void;\n\n  source?: string;\n  getSource(): string | undefined;\n  setSource(source: string): void;\n\n  toString(): string;\n}\n\nfunction StackFrame(obj) {\n  if (!obj) return;\n  for (var i = 0; i < props.length; i++) {\n    if (obj[props[i]] !== undefined) {\n      this[\"set\" + _capitalize(props[i])](obj[props[i]]);\n    }\n  }\n}\n\nStackFrame.prototype = {\n  getArgs: function () {\n    return this.args;\n  },\n  setArgs: function (v) {\n    if (Object.prototype.toString.call(v) !== \"[object Array]\") {\n      throw new TypeError(\"Args must be an Array\");\n    }\n    this.args = v;\n  },\n\n  getEvalOrigin: function () {\n    return this.evalOrigin;\n  },\n  setEvalOrigin: function (v) {\n    if (v instanceof StackFrame) {\n      this.evalOrigin = v;\n    } else if (v instanceof Object) {\n      this.evalOrigin = new StackFrame(v);\n    } else {\n      throw new TypeError(\"Eval Origin must be an Object or StackFrame\");\n    }\n  },\n\n  toString: function () {\n    var fileName = this.getFileName() || \"\";\n    var lineNumber = this.getLineNumber() || \"\";\n    var columnNumber = this.getColumnNumber() || \"\";\n    var functionName = this.getFunctionName() || \"\";\n    if (this.getIsEval()) {\n      if (fileName) {\n        return (\n          \"[eval] (\" + fileName + \":\" + lineNumber + \":\" + columnNumber + \")\"\n        );\n      }\n      return \"[eval]:\" + lineNumber + \":\" + columnNumber;\n    }\n    if (functionName) {\n      return (\n        functionName +\n        \" (\" +\n        fileName +\n        \":\" +\n        lineNumber +\n        \":\" +\n        columnNumber +\n        \")\"\n      );\n    }\n    return fileName + \":\" + lineNumber + \":\" + columnNumber;\n  },\n};\n\nStackFrame.fromString = function StackFrame$$fromString(str) {\n  var argsStartIndex = str.indexOf(\"(\");\n  var argsEndIndex = str.lastIndexOf(\")\");\n\n  var functionName = str.substring(0, argsStartIndex);\n  var args = str.substring(argsStartIndex + 1, argsEndIndex).split(\",\");\n  var locationString = str.substring(argsEndIndex + 1);\n\n  if (locationString.indexOf(\"@\") === 0) {\n    var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, \"\");\n    var fileName = parts[1];\n    var lineNumber = parts[2];\n    var columnNumber = parts[3];\n  }\n\n  return new StackFrame({\n    functionName: functionName,\n    args: args || undefined,\n    fileName: fileName,\n    lineNumber: lineNumber || undefined,\n    columnNumber: columnNumber || undefined,\n  });\n};\n\nfor (var i = 0; i < booleanProps.length; i++) {\n  StackFrame.prototype[\"get\" + _capitalize(booleanProps[i])] = _getter(\n    booleanProps[i],\n  );\n  StackFrame.prototype[\"set\" + _capitalize(booleanProps[i])] = (function (p) {\n    return function (v) {\n      this[p] = Boolean(v);\n    };\n  })(booleanProps[i]);\n}\n\nfor (var j = 0; j < numericProps.length; j++) {\n  StackFrame.prototype[\"get\" + _capitalize(numericProps[j])] = _getter(\n    numericProps[j],\n  );\n  StackFrame.prototype[\"set\" + _capitalize(numericProps[j])] = (function (p) {\n    return function (v) {\n      if (!_isNumber(v)) {\n        throw new TypeError(p + \" must be a Number\");\n      }\n      this[p] = Number(v);\n    };\n  })(numericProps[j]);\n}\n\nfor (var k = 0; k < stringProps.length; k++) {\n  StackFrame.prototype[\"get\" + _capitalize(stringProps[k])] = _getter(\n    stringProps[k],\n  );\n  StackFrame.prototype[\"set\" + _capitalize(stringProps[k])] = (function (p) {\n    return function (v) {\n      this[p] = String(v);\n    };\n  })(stringProps[k]);\n}\n\nexport default StackFrame;\n","// @ts-nocheck\n// Port of https://github.com/stacktracejs/error-stack-parser\n// Rewritten to ES6 and removed UMD and CommonJS support.\n// Removed old opera support.\n\nimport StackFrame from \"./stackframe\";\n\ndeclare namespace ErrorStackParser {\n  export type { StackFrame };\n  /**\n   * Given an Error object, extract the most information from it.\n   *\n   * @param {Error} error object\n   * @return {Array} of StackFrames\n   */\n  export function parse(error: Error): StackFrame[];\n}\n\nfunction ErrorStackParser() {\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error: Error): StackFrame[] {\n      if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error(\"Cannot parse given Error object\");\n      }\n    },\n\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(\":\") === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, \"\"));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split(\"\\n\").filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n\n      return filtered.map(function (line) {\n        if (line.indexOf(\"(eval \") > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line\n            .replace(/eval code/g, \"eval\")\n            .replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n        }\n        var sanitizedLine = line\n          .replace(/^\\s+/, \"\")\n          .replace(/\\(eval code/g, \"(\")\n          .replace(/^.*?\\s+/, \"\");\n\n        // capture and preserve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n        var location = sanitizedLine.match(/ (\\(.+\\)$)/);\n\n        // remove the parenthesized location from the line, if it was matched\n        sanitizedLine = location\n          ? sanitizedLine.replace(location[0], \"\")\n          : sanitizedLine;\n\n        // if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n        // because this line doesn't have function name\n        var locationParts = this.extractLocation(\n          location ? location[1] : sanitizedLine,\n        );\n        var functionName = (location && sanitizedLine) || undefined;\n        var fileName =\n          [\"eval\", \"<anonymous>\"].indexOf(locationParts[0]) > -1\n            ? undefined\n            : locationParts[0];\n\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line,\n        });\n      }, this);\n    },\n\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split(\"\\n\").filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(\" > eval\") > -1) {\n          line = line.replace(\n            / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n            \":$1\",\n          );\n        }\n\n        if (line.indexOf(\"@\") === -1 && line.indexOf(\":\") === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line,\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(\n            line.replace(functionNameRegex, \"\"),\n          );\n\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line,\n          });\n        }\n      }, this);\n    },\n  };\n}\n\nconst errorStackParser = new ErrorStackParser();\n\nexport { StackFrame };\nexport default errorStackParser;\n","// @ts-nocheck\n\n/** @private */\nexport const IN_NODE =\n  typeof process === \"object\" &&\n  typeof process.versions === \"object\" &&\n  typeof process.versions.node === \"string\" &&\n  !process.browser; /* This last condition checks if we run the browser shim of process */\n\n/** @private */\nexport const IN_NODE_COMMONJS =\n  IN_NODE &&\n  typeof module !== \"undefined\" &&\n  typeof module.exports !== \"undefined\" &&\n  typeof require !== \"undefined\" &&\n  typeof __dirname !== \"undefined\";\n\n/** @private */\nexport const IN_NODE_ESM = IN_NODE && !IN_NODE_COMMONJS;\n\n/** @private */\nexport const IN_BUN = typeof globalThis.Bun !== \"undefined\";\n\n/** @private */\nexport const IN_DENO = typeof Deno !== \"undefined\"; // just in case...\n\n/** @private */\nexport const IN_BROWSER = !IN_NODE && !IN_DENO;\n\n/** @private */\nexport const IN_BROWSER_MAIN_THREAD =\n  IN_BROWSER &&\n  typeof window === \"object\" &&\n  typeof document === \"object\" &&\n  typeof document.createElement === \"function\" &&\n  \"sessionStorage\" in window &&\n  typeof importScripts !== \"function\";\n\n/** @private */\nexport const IN_BROWSER_WEB_WORKER =\n  IN_BROWSER && typeof importScripts === \"function\" && typeof self === \"object\";\n\n/** @private */\nexport const IN_SAFARI =\n  typeof navigator === \"object\" &&\n  typeof navigator.userAgent === \"string\" &&\n  navigator.userAgent.indexOf(\"Chrome\") == -1 &&\n  navigator.userAgent.indexOf(\"Safari\") > -1;\n\n/**\n * Detects the current environment and returns a record with the results.\n * This function is useful for debugging and testing purposes.\n * @private\n */\nexport function detectEnvironment(): Record<string, boolean> {\n  return {\n    IN_NODE: IN_NODE,\n    IN_NODE_COMMONJS: IN_NODE_COMMONJS,\n    IN_NODE_ESM: IN_NODE_ESM,\n    IN_BUN: IN_BUN,\n    IN_DENO: IN_DENO,\n    IN_BROWSER: IN_BROWSER,\n    IN_BROWSER_MAIN_THREAD: IN_BROWSER_MAIN_THREAD,\n    IN_BROWSER_WEB_WORKER: IN_BROWSER_WEB_WORKER,\n    IN_SAFARI: IN_SAFARI,\n  };\n}\n","import ErrorStackParser from \"./vendor/stackframe/error-stack-parser\";\nimport {\n  IN_NODE,\n  IN_NODE_ESM,\n  IN_BROWSER_MAIN_THREAD,\n  IN_BROWSER_WEB_WORKER,\n  IN_NODE_COMMONJS,\n} from \"./environments\";\nimport { Lockfile } from \"./types\";\n\nlet nodeUrlMod: typeof import(\"node:url\");\nlet nodePath: typeof import(\"node:path\");\nlet nodeVmMod: typeof import(\"node:vm\");\n/** @private */\nexport let nodeFSMod: typeof import(\"node:fs\");\n/** @private */\nexport let nodeFsPromisesMod: typeof import(\"node:fs/promises\");\n\ndeclare var globalThis: {\n  importScripts: (url: string) => void;\n  document?: typeof document;\n  fetch?: typeof fetch;\n};\n\n/**\n * If we're in node, it's most convenient to import various node modules on\n * initialization. Otherwise, this does nothing.\n * @private\n */\nexport async function initNodeModules() {\n  if (!IN_NODE) {\n    return;\n  }\n  // @ts-ignore\n  nodeUrlMod = (await import(\"node:url\")).default;\n  nodeFSMod = await import(\"node:fs\");\n  nodeFsPromisesMod = await import(\"node:fs/promises\");\n\n  // @ts-ignore\n  nodeVmMod = (await import(\"node:vm\")).default;\n  nodePath = await import(\"node:path\");\n  pathSep = nodePath.sep;\n\n  // Emscripten uses `require`, so if it's missing (because we were imported as\n  // an ES6 module) we need to polyfill `require` with `import`. `import` is\n  // async and `require` is synchronous, so we import all packages that might be\n  // required up front and define require to look them up in this table.\n\n  if (typeof require !== \"undefined\") {\n    return;\n  }\n  // These are all the packages required in pyodide.asm.js. You can get this\n  // list with:\n  // $ grep -o 'require(\"[a-z]*\")' pyodide.asm.js  | sort -u\n  const fs = nodeFSMod;\n  const crypto = await import(\"node:crypto\");\n  const ws = await import(\"ws\");\n  const child_process = await import(\"node:child_process\");\n  const node_modules: { [mode: string]: any } = {\n    fs,\n    crypto,\n    ws,\n    child_process,\n  };\n  // Since we're in an ES6 module, this is only modifying the module namespace,\n  // it's still private to Pyodide.\n  (globalThis as any).require = function (mod: string): any {\n    return node_modules[mod];\n  };\n}\n\nfunction node_resolvePath(path: string, base?: string): string {\n  return nodePath.resolve(base || \".\", path);\n}\n\nfunction browser_resolvePath(path: string, base?: string): string {\n  if (base === undefined) {\n    // @ts-ignore\n    base = location;\n  }\n  return new URL(path, base).toString();\n}\n\nexport let resolvePath: (rest: string, base?: string) => string;\nif (IN_NODE) {\n  resolvePath = node_resolvePath;\n} else {\n  resolvePath = browser_resolvePath;\n}\n\n/**\n * Get the path separator. If we are on Linux or in the browser, it's /.\n * In Windows, it's \\.\n * @private\n */\nexport let pathSep: string;\n\nif (!IN_NODE) {\n  pathSep = \"/\";\n}\n\n/**\n * Load a binary file, only for use in Node. If the path explicitly is a URL,\n * then fetch from a URL, else load from the file system.\n * @param indexURL base path to resolve relative paths\n * @param path the path to load\n * @param checksum sha-256 checksum of the package\n * @returns An ArrayBuffer containing the binary data\n * @private\n */\nfunction node_getBinaryResponse(\n  path: string,\n  _file_sub_resource_hash?: string | undefined, // Ignoring sub resource hash. See issue-2431.\n):\n  | { response: Promise<Response>; binary?: undefined }\n  | { binary: Promise<Uint8Array> } {\n  if (path.startsWith(\"file://\")) {\n    // handle file:// with filesystem operations rather than with fetch.\n    path = path.slice(\"file://\".length);\n  }\n  if (path.includes(\"://\")) {\n    // If it has a protocol, make a fetch request\n    return { response: fetch(path) };\n  } else {\n    // Otherwise get it from the file system\n    return {\n      binary: nodeFsPromisesMod\n        .readFile(path)\n        .then(\n          (data: Buffer) =>\n            new Uint8Array(data.buffer, data.byteOffset, data.byteLength),\n        ),\n    };\n  }\n}\n\n/**\n * Load a binary file, only for use in browser. Resolves relative paths against\n * indexURL.\n *\n * @param path the path to load\n * @param subResourceHash the sub resource hash for fetch() integrity check\n * @returns A Uint8Array containing the binary data\n * @private\n */\nfunction browser_getBinaryResponse(\n  path: string,\n  subResourceHash: string | undefined,\n): { response: Promise<Response>; binary?: undefined } {\n  const url = new URL(path, location as unknown as URL);\n  let options = subResourceHash ? { integrity: subResourceHash } : {};\n  return { response: fetch(url, options) };\n}\n\n/** @private */\nexport let getBinaryResponse: (\n  path: string,\n  file_sub_resource_hash?: string | undefined,\n) =>\n  | { response: Promise<Response>; binary?: undefined }\n  | { response?: undefined; binary: Promise<Uint8Array> };\nif (IN_NODE) {\n  getBinaryResponse = node_getBinaryResponse;\n} else {\n  getBinaryResponse = browser_getBinaryResponse;\n}\n\nexport async function loadBinaryFile(\n  path: string,\n  file_sub_resource_hash?: string | undefined,\n): Promise<Uint8Array> {\n  const { response, binary } = getBinaryResponse(path, file_sub_resource_hash);\n  if (binary) {\n    return binary;\n  }\n  const r = await response;\n  if (!r.ok) {\n    throw new Error(`Failed to load '${path}': request failed.`);\n  }\n  return new Uint8Array(await r.arrayBuffer());\n}\n\n/**\n * Currently loadScript is only used once to load `pyodide.asm.js`.\n * @param url\n * @private\n */\nexport let loadScript: (url: string) => Promise<void>;\n\nif (IN_BROWSER_MAIN_THREAD) {\n  // browser\n  loadScript = async (url) => await import(/* webpackIgnore: true */ url);\n} else if (IN_BROWSER_WEB_WORKER) {\n  // webworker\n  loadScript = async (url) => {\n    try {\n      // use importScripts in classic web worker\n      globalThis.importScripts(url);\n    } catch (e) {\n      // importScripts throws TypeError in a module type web worker, use import instead\n      if (e instanceof TypeError) {\n        await import(/* webpackIgnore: true */ url);\n      } else {\n        throw e;\n      }\n    }\n  };\n} else if (IN_NODE) {\n  loadScript = nodeLoadScript;\n} else {\n  throw new Error(\"Cannot determine runtime environment\");\n}\n\n/**\n * Load a text file and executes it as Javascript\n * @param url The path to load. May be a url or a relative file system path.\n * @private\n */\nasync function nodeLoadScript(url: string) {\n  if (url.startsWith(\"file://\")) {\n    // handle file:// with filesystem operations rather than with fetch.\n    url = url.slice(\"file://\".length);\n  }\n  if (url.includes(\"://\")) {\n    // If it's a url, load it with fetch then eval it.\n    nodeVmMod.runInThisContext(await (await fetch(url)).text());\n  } else {\n    // Otherwise, hopefully it is a relative path we can load from the file\n    // system.\n    await import(/* webpackIgnore: true */ nodeUrlMod.pathToFileURL(url).href);\n  }\n}\n\nexport async function loadLockFile(lockFileURL: string): Promise<Lockfile> {\n  if (IN_NODE) {\n    await initNodeModules();\n    const package_string = await nodeFsPromisesMod.readFile(lockFileURL, {\n      encoding: \"utf8\",\n    });\n    return JSON.parse(package_string);\n  } else {\n    let response = await fetch(lockFileURL);\n    return await response.json();\n  }\n}\n\n/**\n * Calculate the directory name of the current module.\n * This is used to guess the indexURL when it is not provided.\n */\nexport async function calculateDirname(): Promise<string> {\n  if (IN_NODE_COMMONJS) {\n    return __dirname;\n  }\n\n  let err: Error;\n  try {\n    throw new Error();\n  } catch (e) {\n    err = e as Error;\n  }\n  let fileName = ErrorStackParser.parse(err)[0].fileName!;\n\n  if (IN_NODE && !fileName.startsWith(\"file://\")) {\n    fileName = `file://${fileName}`; // Error stack filenames are not starting with `file://` in `Bun`\n  }\n\n  if (IN_NODE_ESM) {\n    const nodePath = await import(\"node:path\");\n    const nodeUrl = await import(\"node:url\");\n\n    // FIXME: We would like to use import.meta.url here,\n    // but mocha seems to mess with compiling typescript files to ES6.\n    return nodeUrl.fileURLToPath(nodePath.dirname(fileName));\n  }\n\n  const indexOfLastSlash = fileName.lastIndexOf(pathSep);\n  if (indexOfLastSlash === -1) {\n    throw new Error(\n      \"Could not extract indexURL path from pyodide module location\",\n    );\n  }\n  return fileName.slice(0, indexOfLastSlash);\n}\n\n/**\n * Ensure that the directory exists before trying to download files into it (Node.js only).\n * @param dir The directory to ensure exists\n */\nexport async function ensureDirNode(dir: string) {\n  if (!IN_NODE) {\n    return;\n  }\n\n  try {\n    // Check if the `installBaseUrl` directory exists\n    await nodeFsPromisesMod.stat(dir); // Use `.stat()` which works even on ASAR archives of Electron apps, while `.access` doesn't.\n  } catch {\n    // If it doesn't exist, make it. Call mkdir() here only when necessary after checking the existence to avoid an error on read-only file systems. See https://github.com/pyodide/pyodide/issues/4736\n    await nodeFsPromisesMod.mkdir(dir, {\n      recursive: true,\n    });\n  }\n}\n","import { Module } from \"./types\";\n\n/**\n * @private\n */\nasync function syncfs(m: Module, direction: boolean): Promise<void> {\n  return new Promise((resolve, reject) => {\n    m.FS.syncfs(direction, (err: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n/**\n * @private\n */\nexport async function syncLocalToRemote(m: Module): Promise<void> {\n  return await syncfs(m, false);\n}\n\n/**\n * @private\n */\nexport async function syncRemoteToLocal(m: Module): Promise<void> {\n  return await syncfs(m, true);\n}\n\n/**\n * @private\n */\nexport function initializeNativeFS(module: Module) {\n  const FS = module.FS;\n  const MEMFS = module.FS.filesystems.MEMFS;\n  const PATH = module.PATH;\n\n  const nativeFSAsync = {\n    // DIR_MODE: {{{ cDefine('S_IFDIR') }}} | 511 /* 0777 */,\n    // FILE_MODE: {{{ cDefine('S_IFREG') }}} | 511 /* 0777 */,\n    DIR_MODE: 16384 | 511,\n    FILE_MODE: 32768 | 511,\n    mount: function (mount: any) {\n      if (!mount.opts.fileSystemHandle) {\n        throw new Error(\"opts.fileSystemHandle is required\");\n      }\n\n      // reuse all of the core MEMFS functionality\n      return MEMFS.mount.apply(null, arguments);\n    },\n    syncfs: async (mount: any, populate: Boolean, callback: Function) => {\n      try {\n        const local = nativeFSAsync.getLocalSet(mount);\n        const remote = await nativeFSAsync.getRemoteSet(mount);\n        const src = populate ? remote : local;\n        const dst = populate ? local : remote;\n        await nativeFSAsync.reconcile(mount, src, dst);\n        callback(null);\n      } catch (e) {\n        callback(e);\n      }\n    },\n    // Returns file set of emscripten's filesystem at the mountpoint.\n    getLocalSet: (mount: any) => {\n      let entries = Object.create(null);\n\n      function isRealDir(p: string) {\n        return p !== \".\" && p !== \"..\";\n      }\n\n      function toAbsolute(root: string) {\n        return (p: string) => {\n          return PATH.join2(root, p);\n        };\n      }\n\n      let check = FS.readdir(mount.mountpoint)\n        .filter(isRealDir)\n        .map(toAbsolute(mount.mountpoint));\n\n      while (check.length) {\n        let path = check.pop();\n        let stat = FS.stat(path);\n\n        if (FS.isDir(stat.mode)) {\n          check.push.apply(\n            check,\n            FS.readdir(path).filter(isRealDir).map(toAbsolute(path)),\n          );\n        }\n\n        entries[path] = { timestamp: stat.mtime, mode: stat.mode };\n      }\n\n      return { type: \"local\", entries: entries };\n    },\n    // Returns file set of the real, on-disk filesystem at the mountpoint.\n    getRemoteSet: async (mount: any) => {\n      // TODO: this should be a map.\n      const entries = Object.create(null);\n\n      const handles = await getFsHandles(mount.opts.fileSystemHandle);\n      for (const [path, handle] of handles) {\n        if (path === \".\") continue;\n\n        entries[PATH.join2(mount.mountpoint, path)] = {\n          timestamp:\n            handle.kind === \"file\"\n              ? (await handle.getFile()).lastModifiedDate\n              : new Date(),\n          mode:\n            handle.kind === \"file\"\n              ? nativeFSAsync.FILE_MODE\n              : nativeFSAsync.DIR_MODE,\n        };\n      }\n\n      return { type: \"remote\", entries, handles };\n    },\n    loadLocalEntry: (path: string) => {\n      const lookup = FS.lookupPath(path);\n      const node = lookup.node;\n      const stat = FS.stat(path);\n\n      if (FS.isDir(stat.mode)) {\n        return { timestamp: stat.mtime, mode: stat.mode };\n      } else if (FS.isFile(stat.mode)) {\n        node.contents = MEMFS.getFileDataAsTypedArray(node);\n        return {\n          timestamp: stat.mtime,\n          mode: stat.mode,\n          contents: node.contents,\n        };\n      } else {\n        throw new Error(\"node type not supported\");\n      }\n    },\n    storeLocalEntry: (path: string, entry: any) => {\n      if (FS.isDir(entry[\"mode\"])) {\n        FS.mkdirTree(path, entry[\"mode\"]);\n      } else if (FS.isFile(entry[\"mode\"])) {\n        FS.writeFile(path, entry[\"contents\"], { canOwn: true });\n      } else {\n        throw new Error(\"node type not supported\");\n      }\n\n      FS.chmod(path, entry[\"mode\"]);\n      FS.utime(path, entry[\"timestamp\"], entry[\"timestamp\"]);\n    },\n    removeLocalEntry: (path: string) => {\n      var stat = FS.stat(path);\n\n      if (FS.isDir(stat.mode)) {\n        FS.rmdir(path);\n      } else if (FS.isFile(stat.mode)) {\n        FS.unlink(path);\n      }\n    },\n    loadRemoteEntry: async (handle: any) => {\n      if (handle.kind === \"file\") {\n        const file = await handle.getFile();\n        return {\n          contents: new Uint8Array(await file.arrayBuffer()),\n          mode: nativeFSAsync.FILE_MODE,\n          timestamp: file.lastModifiedDate,\n        };\n      } else if (handle.kind === \"directory\") {\n        return {\n          mode: nativeFSAsync.DIR_MODE,\n          timestamp: new Date(),\n        };\n      } else {\n        throw new Error(\"unknown kind: \" + handle.kind);\n      }\n    },\n    storeRemoteEntry: async (handles: any, path: string, entry: any) => {\n      const parentDirHandle = handles.get(PATH.dirname(path));\n      const handle = FS.isFile(entry.mode)\n        ? await parentDirHandle.getFileHandle(PATH.basename(path), {\n            create: true,\n          })\n        : await parentDirHandle.getDirectoryHandle(PATH.basename(path), {\n            create: true,\n          });\n      if (handle.kind === \"file\") {\n        const writable = await handle.createWritable();\n        await writable.write(entry.contents);\n        await writable.close();\n      }\n      handles.set(path, handle);\n    },\n    removeRemoteEntry: async (handles: any, path: string) => {\n      const parentDirHandle = handles.get(PATH.dirname(path));\n      await parentDirHandle.removeEntry(PATH.basename(path));\n      handles.delete(path);\n    },\n    reconcile: async (mount: any, src: any, dst: any) => {\n      let total = 0;\n\n      const create: Array<string> = [];\n      Object.keys(src.entries).forEach(function (key) {\n        const e = src.entries[key];\n        const e2 = dst.entries[key];\n        if (\n          !e2 ||\n          (FS.isFile(e.mode) &&\n            e[\"timestamp\"].getTime() > e2[\"timestamp\"].getTime())\n        ) {\n          create.push(key);\n          total++;\n        }\n      });\n      // sort paths in ascending order so directory entries are created\n      // before the files inside them\n      create.sort();\n\n      const remove: Array<string> = [];\n      Object.keys(dst.entries).forEach(function (key) {\n        if (!src.entries[key]) {\n          remove.push(key);\n          total++;\n        }\n      });\n      // sort paths in descending order so files are deleted before their\n      // parent directories\n      remove.sort().reverse();\n\n      if (!total) {\n        return;\n      }\n\n      const handles = src.type === \"remote\" ? src.handles : dst.handles;\n\n      for (const path of create) {\n        const relPath = PATH.normalize(\n          path.replace(mount.mountpoint, \"/\"),\n        ).substring(1);\n        if (dst.type === \"local\") {\n          const handle = handles.get(relPath);\n          const entry = await nativeFSAsync.loadRemoteEntry(handle);\n          nativeFSAsync.storeLocalEntry(path, entry);\n        } else {\n          const entry = nativeFSAsync.loadLocalEntry(path);\n          await nativeFSAsync.storeRemoteEntry(handles, relPath, entry);\n        }\n      }\n\n      for (const path of remove) {\n        if (dst.type === \"local\") {\n          nativeFSAsync.removeLocalEntry(path);\n        } else {\n          const relPath = PATH.normalize(\n            path.replace(mount.mountpoint, \"/\"),\n          ).substring(1);\n          await nativeFSAsync.removeRemoteEntry(handles, relPath);\n        }\n      }\n    },\n  };\n\n  module.FS.filesystems.NATIVEFS_ASYNC = nativeFSAsync;\n}\n\nconst getFsHandles = async (dirHandle: any) => {\n  const handles: any = [];\n\n  async function collect(curDirHandle: any) {\n    for await (const entry of curDirHandle.values()) {\n      handles.push(entry);\n      if (entry.kind === \"directory\") {\n        await collect(entry);\n      }\n    }\n  }\n\n  await collect(dirHandle);\n\n  const result = new Map();\n  result.set(\".\", dirHandle);\n  for (const handle of handles) {\n    const relativePath = (await dirHandle.resolve(handle)).join(\"/\");\n    result.set(relativePath, handle);\n  }\n  return result;\n};\n","/** @private */\n\nimport { ConfigType } from \"./pyodide\";\nimport { initializeNativeFS } from \"./nativefs\";\nimport { loadBinaryFile, getBinaryResponse } from \"./compat\";\nimport { API, PreRunFunc } from \"./types\";\n\n/**\n * @private\n * @hidden\n */\nexport interface EmscriptenSettings {\n  readonly noImageDecoding?: boolean;\n  readonly noAudioDecoding?: boolean;\n  readonly noWasmDecoding?: boolean;\n  readonly preRun: readonly PreRunFunc[];\n  readonly quit: (status: number, toThrow: Error) => void;\n  readonly print?: (a: string) => void;\n  readonly printErr?: (a: string) => void;\n  readonly arguments: readonly string[];\n  readonly instantiateWasm?: (\n    imports: { [key: string]: any },\n    successCallback: (\n      instance: WebAssembly.Instance,\n      module: WebAssembly.Module,\n    ) => void,\n  ) => void;\n  readonly API: API;\n  readonly locateFile: (file: string) => string;\n\n  exited?: { readonly status: number; readonly toThrow: Error };\n  noInitialRun?: boolean;\n  INITIAL_MEMORY?: number;\n}\n\n/**\n * Get the base settings to use to load Pyodide.\n *\n * @private\n */\nexport function createSettings(config: ConfigType): EmscriptenSettings {\n  const settings: EmscriptenSettings = {\n    noImageDecoding: true,\n    noAudioDecoding: true,\n    noWasmDecoding: false,\n    preRun: getFileSystemInitializationFuncs(config),\n    quit(status: number, toThrow: Error) {\n      // It's a little bit hacky that we set this on the settings object but\n      // it's not that easy to get access to the Module object from here.\n      settings.exited = { status, toThrow };\n      throw toThrow;\n    },\n    print: config.stdout,\n    printErr: config.stderr,\n    arguments: config.args,\n    API: { config } as API,\n    // Emscripten calls locateFile exactly one time with argument\n    // pyodide.asm.wasm to get the URL it should download it from.\n    //\n    // If we set instantiateWasm the return value of locateFile actually is\n    // unused, but Emscripten calls it anyways. We set instantiateWasm except\n    // when compiling with source maps, see comment in getInstantiateWasmFunc().\n    //\n    // It also is called when Emscripten tries to find a dependency of a shared\n    // library but it failed to find it in the file system. But for us that\n    // means dependency resolution has already failed and we want to throw an\n    // error anyways.\n    locateFile: (path: string) => config.indexURL + path,\n    instantiateWasm: getInstantiateWasmFunc(config.indexURL),\n  };\n  return settings;\n}\n\n/**\n * Make the home directory inside the virtual file system,\n * then change the working directory to it.\n *\n * @param Module The Emscripten Module.\n * @param path The path to the home directory.\n * @private\n */\nfunction createHomeDirectory(path: string): PreRunFunc {\n  return function (Module) {\n    const fallbackPath = \"/\";\n    try {\n      Module.FS.mkdirTree(path);\n    } catch (e) {\n      console.error(`Error occurred while making a home directory '${path}':`);\n      console.error(e);\n      console.error(`Using '${fallbackPath}' for a home directory instead`);\n      path = fallbackPath;\n    }\n    Module.FS.chdir(path);\n  };\n}\n\nfunction setEnvironment(env: { [key: string]: string }): PreRunFunc {\n  return function (Module) {\n    Object.assign(Module.ENV, env);\n  };\n}\n\n/**\n * Mount local directories to the virtual file system. Only for Node.js.\n * @param mounts The list of paths to mount.\n */\nfunction mountLocalDirectories(mounts: string[]): PreRunFunc {\n  return (Module) => {\n    for (const mount of mounts) {\n      Module.FS.mkdirTree(mount);\n      Module.FS.mount(Module.FS.filesystems.NODEFS, { root: mount }, mount);\n    }\n  };\n}\n\n/**\n * Install the Python standard library to the virtual file system.\n *\n * Previously, this was handled by Emscripten's file packager (pyodide.asm.data).\n * However, using the file packager means that we have only one version\n * of the standard library available. We want to be able to use different\n * versions of the standard library, for example:\n *\n * - Use compiled(.pyc) or uncompiled(.py) standard library.\n * - Remove unused modules or add additional modules using bundlers like pyodide-pack.\n *\n * @param stdlibURL The URL for the Python standard library\n */\nfunction installStdlib(stdlibURL: string): PreRunFunc {\n  const stdlibPromise: Promise<Uint8Array> = loadBinaryFile(stdlibURL);\n  return (Module) => {\n    /* @ts-ignore */\n    const pymajor = Module._py_version_major();\n    /* @ts-ignore */\n    const pyminor = Module._py_version_minor();\n\n    Module.FS.mkdirTree(\"/lib\");\n    Module.FS.mkdirTree(`/lib/python${pymajor}.${pyminor}/site-packages`);\n\n    Module.addRunDependency(\"install-stdlib\");\n\n    stdlibPromise\n      .then((stdlib: Uint8Array) => {\n        Module.FS.writeFile(`/lib/python${pymajor}${pyminor}.zip`, stdlib);\n      })\n      .catch((e) => {\n        console.error(\"Error occurred while installing the standard library:\");\n        console.error(e);\n      })\n      .finally(() => {\n        Module.removeRunDependency(\"install-stdlib\");\n      });\n  };\n}\n\n/**\n * Initialize the virtual file system, before loading Python interpreter.\n * @private\n */\nfunction getFileSystemInitializationFuncs(config: ConfigType): PreRunFunc[] {\n  let stdLibURL;\n  if (config.stdLibURL != undefined) {\n    stdLibURL = config.stdLibURL;\n  } else {\n    stdLibURL = config.indexURL + \"python_stdlib.zip\";\n  }\n\n  return [\n    installStdlib(stdLibURL),\n    createHomeDirectory(config.env.HOME),\n    setEnvironment(config.env),\n    mountLocalDirectories(config._node_mounts),\n    initializeNativeFS,\n  ];\n}\n\nfunction getInstantiateWasmFunc(\n  indexURL: string,\n): EmscriptenSettings[\"instantiateWasm\"] {\n  // @ts-ignore\n  if (SOURCEMAP || typeof WasmOffsetConverter !== \"undefined\") {\n    // According to the docs:\n    //\n    // \"Sanitizers or source map is currently not supported if overriding\n    // WebAssembly instantiation with Module.instantiateWasm.\"\n    // https://emscripten.org/docs/api_reference/module.html?highlight=instantiatewasm#Module.instantiateWasm\n    //\n    // typeof WasmOffsetConverter !== \"undefined\" checks for asan.\n    return;\n  }\n  const { binary, response } = getBinaryResponse(indexURL + \"pyodide.asm.wasm\");\n  return function (\n    imports: { [key: string]: any },\n    successCallback: (\n      instance: WebAssembly.Instance,\n      module: WebAssembly.Module,\n    ) => void,\n  ) {\n    (async function () {\n      try {\n        let res: WebAssembly.WebAssemblyInstantiatedSource;\n        if (response) {\n          res = await WebAssembly.instantiateStreaming(response, imports);\n        } else {\n          res = await WebAssembly.instantiate(await binary, imports);\n        }\n        const { instance, module } = res;\n        successCallback(instance, module);\n      } catch (e) {\n        console.warn(\"wasm instantiation failed!\");\n        console.warn(e);\n      }\n    })();\n\n    return {}; // Compiling asynchronously, no exports.\n  };\n}\n","/**\n *\n * The Pyodide version.\n *\n * The version here is a Python version, following :pep:`440`. This is different\n * from the version in ``package.json`` which follows the node package manager\n * version convention.\n */\nexport const version: string = \"0.27.3\";\n","/**\n * The main bootstrap code for loading pyodide.\n */\nimport {\n  calculateDirname,\n  loadScript,\n  initNodeModules,\n  resolvePath,\n  loadLockFile,\n} from \"./compat\";\n\nimport { createSettings } from \"./emscripten-settings\";\nimport { version } from \"./version\";\n\nimport type { PyodideInterface } from \"./api.js\";\nimport type { TypedArray, Module, PackageData } from \"./types\";\nimport type { EmscriptenSettings } from \"./emscripten-settings\";\nimport type { SnapshotConfig } from \"./snapshot\";\nexport type { PyodideInterface, TypedArray };\n\nexport { version, type PackageData };\n\ndeclare function _createPyodideModule(\n  settings: EmscriptenSettings,\n): Promise<Module>;\n\n// BUILD_ID is generated from hashing together pyodide.asm.js and\n// pyodide.asm.wasm in esbuild.config.outer.mjs\n//\n// It is used to check that memory snapshots were generated by the same build of\n// the runtime that is trying to use them. Attempting to use a snapshot from a\n// different build will fail badly. See logic in snapshot.ts.\ndeclare const BUILD_ID: string;\n\n/**\n * See documentation for loadPyodide.\n * @hidden\n */\nexport type ConfigType = {\n  indexURL: string;\n  packageCacheDir: string;\n  lockFileURL: string;\n  fullStdLib?: boolean;\n  stdLibURL?: string;\n  stdin?: () => string;\n  stdout?: (msg: string) => void;\n  stderr?: (msg: string) => void;\n  jsglobals?: object;\n  args: string[];\n  _node_mounts: string[];\n  env: { [key: string]: string };\n  packages: string[];\n  _makeSnapshot: boolean;\n  enableRunUntilComplete: boolean;\n  checkAPIVersion: boolean;\n  BUILD_ID: string;\n};\n\n/**\n * Load the main Pyodide wasm module and initialize it.\n *\n * @returns The :ref:`js-api-pyodide` module.\n * @example\n * async function main() {\n *   const pyodide = await loadPyodide({\n *     fullStdLib: true,\n *     stdout: (msg) => console.log(`Pyodide: ${msg}`),\n *   });\n *   console.log(\"Loaded Pyodide\");\n * }\n * main();\n */\nexport async function loadPyodide(\n  options: {\n    /**\n     * The URL from which Pyodide will load the main Pyodide runtime and\n     * packages. It is recommended that you leave this unchanged, providing an\n     * incorrect value can cause broken behavior.\n     *\n     * Default: The url that Pyodide is loaded from with the file name\n     * (``pyodide.js`` or ``pyodide.mjs``) removed.\n     */\n    indexURL?: string;\n\n    /**\n     * The file path where packages will be cached in node. If a package\n     * exists in ``packageCacheDir`` it is loaded from there, otherwise it is\n     * downloaded from the JsDelivr CDN and then cached into ``packageCacheDir``.\n     * Only applies when running in node; ignored in browsers.\n     *\n     * Default: same as indexURL\n     */\n    packageCacheDir?: string;\n\n    /**\n     * The URL from which Pyodide will load the Pyodide ``pyodide-lock.json`` lock\n     * file. You can produce custom lock files with :py:func:`micropip.freeze`.\n     * Default: ```${indexURL}/pyodide-lock.json```\n     */\n    lockFileURL?: string;\n    /**\n     * Load the full Python standard library. Setting this to false excludes\n     * unvendored modules from the standard library.\n     * Default: ``false``\n     */\n    fullStdLib?: boolean;\n    /**\n     * The URL from which to load the standard library ``python_stdlib.zip``\n     * file. This URL includes the most of the Python standard library. Some\n     * stdlib modules were unvendored, and can be loaded separately\n     * with ``fullStdLib: true`` option or by their package name.\n     * Default: ```${indexURL}/python_stdlib.zip```\n     */\n    stdLibURL?: string;\n    /**\n     * Override the standard input callback. Should ask the user for one line of\n     * input. The :js:func:`pyodide.setStdin` function is more flexible and\n     * should be preferred.\n     */\n    stdin?: () => string;\n    /**\n     * Override the standard output callback. The :js:func:`pyodide.setStdout`\n     * function is more flexible and should be preferred in most cases, but\n     * depending on the ``args`` passed to ``loadPyodide``, Pyodide may write to\n     * stdout on startup, which can only be controlled by passing a custom\n     * ``stdout`` function.\n     */\n    stdout?: (msg: string) => void;\n    /**\n     * Override the standard error output callback. The\n     * :js:func:`pyodide.setStderr` function is more flexible and should be\n     * preferred in most cases, but depending on the ``args`` passed to\n     * ``loadPyodide``, Pyodide may write to stdout on startup, which can only\n     * be controlled by passing a custom ``stdout`` function.\n     */\n    stderr?: (msg: string) => void;\n    /**\n     * The object that Pyodide will use for the ``js`` module.\n     * Default: ``globalThis``\n     */\n    jsglobals?: object;\n    /**\n     * Command line arguments to pass to Python on startup. See `Python command\n     * line interface options\n     * <https://docs.python.org/3.10/using/cmdline.html#interface-options>`_ for\n     * more details. Default: ``[]``\n     */\n    args?: string[];\n    /**\n     * Environment variables to pass to Python. This can be accessed inside of\n     * Python at runtime via :py:data:`os.environ`. Certain environment variables change\n     * the way that Python loads:\n     * https://docs.python.org/3.10/using/cmdline.html#environment-variables\n     * Default: ``{}``.\n     * If ``env.HOME`` is undefined, it will be set to a default value of\n     * ``\"/home/pyodide\"``\n     */\n    env?: { [key: string]: string };\n    /**\n     * A list of packages to load as Pyodide is initializing.\n     *\n     * This is the same as loading the packages with\n     * :js:func:`pyodide.loadPackage` after Pyodide is loaded except using the\n     * ``packages`` option is more efficient because the packages are downloaded\n     * while Pyodide bootstraps itself.\n     */\n    packages?: string[];\n    /**\n     * Opt into the old behavior where :js:func:`PyProxy.toString() <pyodide.ffi.PyProxy.toString>`\n     * calls :py:func:`repr` and not :py:class:`str() <str>`.\n     * @deprecated\n     */\n    pyproxyToStringRepr?: boolean;\n    /**\n     * Make loop.run_until_complete() function correctly using stack switching\n     */\n    enableRunUntilComplete?: boolean;\n    /**\n     * If true (default), throw an error if the version of Pyodide core does not\n     * match the version of the Pyodide js package.\n     */\n    checkAPIVersion?: boolean;\n    /**\n     * Used by the cli runner. If we want to detect a virtual environment from\n     * the host file system, it needs to be visible from when `main()` is\n     * called. The directories in this list will be mounted at the same address\n     * into the Emscripten file system so that virtual environments work in the\n     * cli runner.\n     * @ignore\n     */\n    _node_mounts?: string[];\n    /** @ignore */\n    _makeSnapshot?: boolean;\n    /** @ignore */\n    _loadSnapshot?:\n      | Uint8Array\n      | ArrayBuffer\n      | PromiseLike<Uint8Array | ArrayBuffer>;\n    /** @ignore */\n    _snapshotDeserializer?: (obj: any) => any;\n  } = {},\n): Promise<PyodideInterface> {\n  await initNodeModules();\n  let indexURL = options.indexURL || (await calculateDirname());\n  indexURL = resolvePath(indexURL); // A relative indexURL causes havoc.\n  if (!indexURL.endsWith(\"/\")) {\n    indexURL += \"/\";\n  }\n  options.indexURL = indexURL;\n\n  const default_config = {\n    fullStdLib: false,\n    jsglobals: globalThis,\n    stdin: globalThis.prompt ? globalThis.prompt : undefined,\n    lockFileURL: indexURL + \"pyodide-lock.json\",\n    args: [],\n    _node_mounts: [],\n    env: {},\n    packageCacheDir: indexURL,\n    packages: [],\n    enableRunUntilComplete: false,\n    checkAPIVersion: true,\n    BUILD_ID,\n  };\n  const config = Object.assign(default_config, options) as ConfigType;\n  config.env.HOME ??= \"/home/pyodide\";\n  /**\n   * `PyErr_Print()` will call `exit()` if the exception is a `SystemError`.\n   * This shuts down the Python interpreter, which is a change in behavior from\n   * what happened before. In order to avoid this, we set the `inspect` config\n   * parameter which prevents `PyErr_Print()` from calling `exit()`. Except in\n   * the cli runner, we actually do want to exit. So set default to true and in\n   * cli runner we explicitly set it to false.\n   */\n  config.env.PYTHONINSPECT ??= \"1\";\n  const emscriptenSettings = createSettings(config);\n  const API = emscriptenSettings.API;\n  API.lockFilePromise = loadLockFile(config.lockFileURL);\n\n  // If the pyodide.asm.js script has been imported, we can skip the dynamic import\n  // Users can then do a static import of the script in environments where\n  // dynamic importing is not allowed or not desirable, like module-type service workers\n  if (typeof _createPyodideModule !== \"function\") {\n    const scriptSrc = `${config.indexURL}pyodide.asm.js`;\n    await loadScript(scriptSrc);\n  }\n\n  let snapshot: Uint8Array | undefined = undefined;\n  if (options._loadSnapshot) {\n    const snp = await options._loadSnapshot;\n    if (ArrayBuffer.isView(snp)) {\n      snapshot = snp;\n    } else {\n      snapshot = new Uint8Array(snp);\n    }\n    emscriptenSettings.noInitialRun = true;\n    // @ts-ignore\n    emscriptenSettings.INITIAL_MEMORY = snapshot.length;\n  }\n\n  // _createPyodideModule is specified in the Makefile by the linker flag:\n  // `-s EXPORT_NAME=\"'_createPyodideModule'\"`\n  const Module = await _createPyodideModule(emscriptenSettings);\n  // Handle early exit\n  if (emscriptenSettings.exited) {\n    throw emscriptenSettings.exited.toThrow;\n  }\n  if (options.pyproxyToStringRepr) {\n    API.setPyProxyToStringMethod(true);\n  }\n\n  if (API.version !== version && config.checkAPIVersion) {\n    throw new Error(`\\\nPyodide version does not match: '${version}' <==> '${API.version}'. \\\nIf you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.\\\n`);\n  }\n  // Disable further loading of Emscripten file_packager stuff.\n  Module.locateFile = (path: string) => {\n    throw new Error(\"Didn't expect to load any more file_packager files!\");\n  };\n\n  let snapshotConfig: SnapshotConfig | undefined = undefined;\n  if (snapshot) {\n    snapshotConfig = API.restoreSnapshot(snapshot);\n  }\n  // runPython works starting after the call to finalizeBootstrap.\n  const pyodide = API.finalizeBootstrap(\n    snapshotConfig,\n    options._snapshotDeserializer,\n  );\n  API.sys.path.insert(0, API.config.env.HOME);\n\n  if (!pyodide.version.includes(\"dev\")) {\n    // Currently only used in Node to download packages the first time they are\n    // loaded. But in other cases it's harmless.\n    API.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${pyodide.version}/full/`);\n  }\n  API._pyodide.set_excepthook();\n  await API.packageIndexReady;\n  // I think we want this initializeStreams call to happen after\n  // packageIndexReady? I don't remember why.\n  API.initializeStreams(config.stdin, config.stdout, config.stderr);\n  return pyodide;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}